---
title: "SOLID"
subtitle: "C√≥digo limpo"
author: "Vicente Calfo"
format:
  revealjs:
    logo: http://www.sr2.uerj.br/inovuerj/images/logonova.gif
    footer: "C√≥digo Limpo"
---

# SOLID

SOLID s√£o cinco princ√≠pios da programa√ß√£o orientada a objetos que facilitam no desenvolvimento de softwares, tornando-os f√°ceis de manter e estender. 

- SOLID √© um acr√¥nimo criado por Michael Feathers ap√≥s observar que cinco princ√≠pios da orienta√ß√£o a objetos e design de c√≥digo criados por Uncle Bob descritos nos artigo [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).

## S -> *Single Responsability Principle* (SRP) ou Princ√≠pio da Responsabilidade √önica

Um m√≥dulo deve ter uma, e apenas uma raz√£o para mudar!

Esse princ√≠pio declara que uma classe deve ser especializada em um √∫nico assunto e possuir apenas uma responsabilidade dentro do software, ou seja, a classe deve ter uma √∫nica tarefa ou a√ß√£o para executar.

---

```php

<?php

class Order{

    public function calculateTotalSum(){/*...*/}

    public function getItems(){/*...*/}

    public function getItemCount(){/*...*/}

    public function addItem($item){/*...*/}

    public function deleteItem($item){/*...*/}

    public function printOrder(){/*...*/}

    public function showOrder(){/*...*/}

    public function load(){/*...*/}

    public function save(){/*...*/}

    public function update(){/*...*/}

    public function delete(){/*...*/}

}

```

# GOD Class

<img src="https://upload.wikimedia.org/wikipedia/commons/7/7c/Cima_da_Conegliano%2C_God_the_Father.jpg" style="height:400px; display:block; margin:0 auto;" />

## A classe Order viola o SRP porque realiza 3 tipos distintos de tarefas!

* Falta de coes√£o ‚Äî uma classe n√£o deve assumir responsabilidades que n√£o s√£o suas;
* Alto acoplamento ‚Äî Mais responsabilidades geram um maior n√≠vel de depend√™ncias, deixando o sistema engessado e fr√°gil para altera√ß√µes;
* Dificuldades na implementa√ß√£o de testes automatizados ‚Äî √â dif√≠cil de ‚Äúmockar‚Äù dados para testes;

# Vamos refatorar! 

## O Pedido!

```php
<?php

class Order{

    public function calculateTotalSum(){/*...*/}

    public function getItems(){/*...*/}

    public function getItemCount(){/*...*/}

    public function addItem($item){/*...*/}

    public function deleteItem($item){/*...*/}

}
```

## A persist√™ncia

```php
<?php

class OrderRepository{

    public function load($orderID){/*...*/}

    public function save($order){/*...*/}

    public function update($order){/*...*/}

    public function delete($order){/*...*/}

}
```

## A visualiza√ß√£o

```php
<?php

class OrderViewer{

    public function printOrder($order){/*...*/}

    public function showOrder($order){/*...*/}

}
```

# A tal da alta coes√£o e baixo acoplamento üòé

**O que √© coes√£o?** 
A coes√£o lexical consiste na utiliza√ß√£o de palavras que possuem sentido aproximado ou que pertencem a um mesmo campo lexical.

<hr />

Objetos flex√≠veis e com responsabilidades limitadas!

<hr />

**Exemplo:** Objeto feito para salvar dado no banco **N√ÉO** deve gerar mensagem de log (**n√£o √© coeso**)!

# Uma classe deve ter apenas um motivo para mudar!

# üí©
 ```typescript
class Product{
    constructor(name, price, taxRate){
        this.name = name;
        this.price = price;
        this.taxRate = taxRate;
    }

    calculateTax(){
        return this.price * this.taxRate;
    }
}
```
<hr />

 ```typescript
const coolSneakers = new Product('T√™nis Irado', 55, 0.1);
const coolSneakersTax = coolSneakers.calculateTax();

// output coolSneakersTax: 5.5
```

## Bora Refatorar! ü§ì

 ```typescript
class Product{
    constructor(name, price, taxRate){
        this.name = name;
        this.price = price;
        this.taxRate = taxRate;
    }

   getPrice(){
    return this.price;
   }

   getTaxRate(){
    return this.taxRate;
   }
}
```
<hr />

 ```typescript
class TaxCalculator{
    static calculateTax(product){
        return product.getPrice() * product.getTaxRate();
    }
}
```

# Calculando o imposto

```typescript
const coolSneakers = new Product('T√™nis Irado', 55, 0.1);
const coolSneakersTax = TaxCalculator.calculateTax(coolSneakers);

```

# Bora melhorar isso a√≠?

```typescript
const TAX_RATES = {
    RJ: 0.1,
    SP: 0.2,
    MG: 0.0
};
```
<hr />

 ```typescript
class Product{
    constructor(name, price){
        this.name = name;
        this.price = price;
    }
   getPrice(){
    return this.price;
   }
}
```
---

 ```typescript
class TaxCalculator{
    static calculateTax(product, state){
        return product.getPrice() * TAX_RATES[state];
    }
}
```
<hr />

```typescript
const coolSneakers = new Product('T√™nis Irado', 55);
const coolSneakersTaxInRJ = TaxCalculator.calculateTax(coolSneakers, 'RJ');
const coolSneakersTaxInSP = TaxCalculator.calculateTax(coolSneakers, 'SP');
```

# Vamos para mais um exemplo!

---

```typescript
const sendNewsletter = (book)=> {
  switch (book.category) {
    case "fiction":
      const content = `'${book.title}' √© um dis melhores livros de fic√ß√£o, divirta-se!`;
      break;
    case "cooking":
      const content = `'${book.title}' pode ser um √≥timo presente para seu amigo cozinheiro.` ;
      break;
  }
    database.getAll('customers').forEach(costumer =>{
        if(customer.hasEmailSubscription()){
            const emailContent = `<h1>Our weekly newsletter</h1><p>${content}</p>`
            mailClient.send(emailReceivers, emailContent);
        }
    }) 
}
```
# Hora da refatora√ß√£o!

<img src="https://media.tenor.com/58DNSt-Lvw0AAAAM/corgi-computer.gif" />

---

```typescript
const getMessage ({category, title}) => {
    return {
        fiction: `'${title}' √© um dis melhores livros de fic√ß√£o, divirta-se!`,
        cooking: `'${title}' pode ser um √≥timo presente para seu amigo cozinheiro.`;
    }
}
```
<hr />

```typescript
const sendNewsletter = (book)=> { 
    const content = getMessage(book);
    const customers = database.getAll('customers');
    const hasEmailSubscription = (costumer) => costumer.hasEmailSubscription();
    customers.filter(hasEmailSubscription).forEach((costumer) =>{
        const email = costumer.getEmailAddress();
        sendEmail({
            email,
            content
        })
    });
}

const sendEmail = ({email, content}) => {
    const mailClient = // instancia o cliente
    mailClient.send(customer.getEmailAddress(), content)
}
```

---

```typescript

const getcustomersWhoHasEmailSubscription = () =>{
    const customers = database.getAll('customers');
    const hasEmailSubscription = (costumer) => costumer.hasEmailSubscription();
    return customers.filter(hasEmailSubscription);
}

const sendNewsletter = (book, customers)=> { 
    const content = getMessage(book);
    customers.forEach((costumer) =>{
        const email = costumer.getEmailAddress();
        sendEmail({
            email,
            content
        })
    });
}
```


## O -> *Open-Closed Principle* ou Princ√≠pio aberto-fechado

Objetos ou entidades devem estar abertos para extens√£o, mas fechados para modifica√ß√£o, ou seja, quando novos comportamentos e recursos precisam ser adicionados no software, devemos estender e n√£o alterar o c√≥digo fonte original.

## üí©

```php
<?php

class ContratoClt
{
    public function salario()
    {
        //...
    }
}

class Estagio
{
    public function bolsaAuxilio()
    {
        //...
    }
}
```

## üí©

```php
class FolhaDePagamento
{
    protected $saldo;
    
    public function calcular($funcionario)
    {
        if ( $funcionario instanceof ContratoClt ) {
            $this->saldo = $funcionario->salario();
        } else if ( $funcionario instanceof Estagio) {
            $this->saldo = $funcionario->bolsaAuxilio();
        }
    }
}
```

# Agora precisamos implementar funcion√°rio em regime de PJ! ü§°

## üí©

```php
class ContratoPJ
{
    public function valorDoContrato()
    {
        //...
    }
}
```

## üí©

```php
class FolhaDePagamento
{
    protected $saldo;
    
    public function calcular($funcionario)
    {
        if ( $funcionario instanceof ContratoClt ) {
            $this->saldo = $funcionario->salario();
        } else if ( $funcionario instanceof Estagio) {
            $this->saldo = $funcionario->bolsaAuxilio();
        } else if ( $funcionario instanceof ContratoPJ) {
            $this->saldo = $funcionario->valorDoContrato();
        }
    }
}
```

# Bora melhorar isso a√≠? üòé

# Separe o comportamento extens√≠vel por tr√°s de uma interface e inverta as depend√™ncias.
*Uncle Bob*

## üí°

```php

<?php

interface Remuneravel
{
    public function remuneracao();
}

```

---

```php
<?php

class ContratoClt implements Remuneravel
{
    public function remuneracao()
    {
        //...
    }
}

class Estagio implements Remuneravel
{
    public function remuneracao()
    {
        //...
    }
}
```

---

## üí°

```php
<?php

class ContratoPJ implements Remuneravel
{
    public function remuneracao()
    {
        //...
    }
}
```
<hr />

```php
class FolhaDePagamento
{
    protected $saldo;
    
    public function calcular(Remuneravel $funcionario)
    {
        $this->saldo = $funcionario->remuneracao();
    }
}
```

# Agora a classe FolhaDePagamento n√£o precisa mais saber quais m√©todos chamar para calcular.  ü§å

# Open-Closed Principle tamb√©m √© base para o padr√£o de projeto *Strategy*!

At√© o final do curso n√≥s veremos esse padr√£o de projeto! (Prometo ü§û)

# Vamos mais um exemplo?

## üí©

```typescript
class CartaoCredito {

  private Codigo: String;
  private Expiracao: Date;
  protected CustoMensal: number;

  constructor(codigo: String, expiracao: Date, custoMensal: number) {
      this.Codigo = codigo;
      this.Expiracao = expiracao;
      this.CustoMensal = custoMensal;
  }

  obterCodigo(): String {
      return this.Codigo;
  }

  obterExpiracao(): Date {
      return this.Expiracao;
  }

  descontoMensal(): number {
      return this.CustoMensal * 0.02;
  }

  descontoMensalSilver(): number {
      return this.CustoMensal * 0.03;
  }

  descontoMensalGold(): number {
      return this.CustoMensal * 0.05;
  }

}
```

# Hora da Refatora√ß√£o

<img src="https://gifs.eco.br/wp-content/uploads/2022/02/gifs-do-gatinho-digitando-2.gif" />

## üòç

```typescript
class CartaoCredito {

  private Codigo: String;
  private Expiracao: Date;
  protected CustoMensal: number;

  constructor(codigo: String, expiracao: Date, custoMensal: number) {
      this.Codigo = codigo;
      this.Expiracao = expiracao;
      this.CustoMensal = custoMensal;
  }

  obterCodigo(): String {
      return this.Codigo;
  }

  obterExpiracao(): Date {
      return this.Expiracao;
  }

  descontoMensal(): number {
      return this.CustoMensal * 0.02;
  }

}
```

## üòç

```typescript
class CartaoCreditoGold extends CartaoCredito {

  descontoMensal(): number {
    return this.CustoMensal * 0.05;
  }

}


class CartaoCreditoSilver extends CartaoCredito {

  descontoMensal(): number {
      return this.CustoMensal * 0.03;
  }

}
```

# Voc√™ deve ser capaz de estender o comportamento de uma classe sem modifica-la!

# L -> *Liskov substitution principle* ou Princ√≠pio da Substitui√ß√£o de Liskov

Este conceito foi introduzido por Barbara Liskov em 1987, no qual defende a ideia que uma classe base pode ser substitu√≠da em qualquer momento por suas classes herdadas sem ser modificada.

## Observe:
```typescript
export interface Cliente {
  recuperarDocumento();
  calcularTarifa();
}

export class Program {
  private _clientes: Cliente[];

  constructor(clientes: Cliente[]) {
    this._clientes = clientes;
  }

  exibirRelatorio() {
    this._clientes.forEach((cliente) => {
      const documento = cliente.recuperarDocumento();
      const tarifa = cliente.calcularTarifa();
      console.log(`${documento} | ${tarifa}`);
    })
  }
}
```

#
```typescript
export class ClientePF implements Cliente {
  private _cpf: string;

  constructor(cpf: string) {
    if (cpf.length !== 11) {
      throw new Error("O CPF de um Cliente pessoa f√≠sica deve conter exatamente 11 d√≠gitos");
    }

    this._cpf = cpf;
  }

  recuperarDocumento() {
    return this._cpf;
  }

  calcularTarifa() {
    /** regras para calcular tarifa de um cliente PF */
  }
}
```

#
```typescript
export class ClientePJ implements Cliente {
  private _cnpj: string;

  constructor(cnpj: string) {
    if (cnpj.length !== 14) {
      throw new Error("O CNPJ de um Cliente pessoa jur√≠dica deve conter exatamente 14 d√≠gitos");
    }

    this._cnpj = cnpj;
  }

  recuperarDocumento() {
    return this._cnpj;
  }

  calcularTarifa() {
    /** regras para calcular tarifa de um cliente PJ */
  }
}
```

# Conclus√£o ü§ì
Temos duas classes que representam tipos diferentes de clientes, cada uma com suas regras de neg√≥cio espec√≠ficas, por√©m ambas respeitam o contrato da interface Cliente. Assim, o programa est√° preparado para receber em seu construtor qualquer uma das duas implementa√ß√µes.

# Situa√ß√£o problema ü§î
Imagine que nosso sistema precise salvar um usu√°rio no banco de dados, mas queremos ter total independ√™ncia em rela√ß√£o ao banco que ser√° utilizado, pois ainda n√£o escolhemos qual banco.

## *Repository Pattern*

- Conceito de abstra√ß√£o de banco de dados e implementar um padr√£o de design "Repository".

- Vamos criar um "contrato" que diga que todo toda classe que lide com o banco de dados tenha um m√©todo chamado "create".

```typescript
interface IUserRepository {
  create(name: string, age: number): Promise<void>;
}
```

# Lidando com MYSQL

```typescript
import mysql from 'mysql2/promise';  // S√≥ exemplo

class UserRepositoryMySQL implements IUserRepository {
  constructor() {
    this.mysql = mysql.createPool({
      /* configura√ß√£o da conex√£o */
    });
  }

    async create(name: string, age: number): Promise<void> {
      await this.mysql.execute(
        'INSERT INTO users (name, age) VALUES (?, ?);',
        [name, age]
      )
    }
  }
```

# Lidando com MongoDB

```typescript
// pasta "fict√≠cia"que armazena as Models do Mongoose

import { User } from 'mongooseModels';  

class UserRepositoryMongo implements IUserRepository {
  constructor() {
    this.userModel = new User();
  }

  async create(name: string, age: number): Promise<void> {
    await this.userMode.create({ name, age });
  }
}
```

# Criando um servi√ßo

```typescript
import { IUserRepository } from 'IUserRepository';

class CreateUserService {
  constructor(private userRepository: IUserRepository) {}

  async execute(name: string, age: number) {
    this.userRepository.create(name, age);
  }
}
```

# Salvando no banco 

```typescript
import { UserRepositoryMySQL } from 'UserRepositoryMySQL';
import { UserRepositoryMongo } from 'UserRepositoryMongo';
import { CreateUserService } from 'CreateUserService';


const createUserService = new CreateUserService(userRepositoryMySQL);
//ou
const createUserService = new CreateUserService(userRepositoryMongo);
await createUserService.execute('Vicente', 40);
```

# Conclus√£o üòç

Criamos duas classes que lidam com DB diferentes, por√©m podemos utilizar qualquer uma das duas em nosso servi√ßo de cria√ß√£o de usu√°rio *CreateUserService*, isso porque o servi√ßo espera a *Interface IUserRepository* e como nossas classes implementam essa Interface podem ser usadas como substitutas.

##  I -> *Interface Segregation Principle* ou Princ√≠pio de Segrega√ß√£o de Interfaces

O Princ√≠pio de Segrega√ß√£o de Interfaces recomenda que separemos nossas Interfaces em "blocos m√≠nimos", em outras palavras, as criemos altamente especializadas e caso surja a necessidade, podemos criar uma Interface mais completa estendendo as mais espec√≠ficas.

## Vamos ao exemplo! 

```typescript
export interface Carro {
  acelerar();
  frear();
}
```

# üöó
```typescript
export class Fiat implements Carro {
  acelerar() {
    console.log('O Fiat est√° sendo acelerada');
  }
 
  frear() {
    console.log('Voc√™ acabou de frear o Fiat');
  }
}
 
export class Ford implements Carro {
  acelerar() {
    console.log('O Ford est√° sendo acelerada');
  }
 
  frear() {
    console.log('Voc√™ acabou de frear o Ford');
  }
}
```

# Aqui t√° tudo certo! ISP sendo aplicado, at√© ...

# ... o Wellington ter uma grande ideia üßë‚Äçüî¨
Ele inventou um carro que viaja no tempo chamado **DeLorean**! 

## Ele deu um jeitinho nas coisas ü§°

```typescript
export interface Carro {
  acelerar();
  frear();
  viajarNoTempo();
}

export class DeLorean implements Carro {
  acelerar() {
    console.log('O DeLorean est√° sendo acelerado');
  }
 
  frear() {
    console.log('Voc√™ acabou de frear o DeLorean');
  }
 
  viajarNoTempo() {
    console.log('Vamos de volta para o futuro com o DeLorean');
  }
}
```

# Qual √© o fedor na solu√ß√£o anterior???? üí©
O Compilador est√° nos for√ßando a implementar o m√©todo viajarNoTempo() nas classes Fiat e Ford, por mais que este comportamento n√£o exista nestes tipos de carro!

## Mas Wellington logo percebeu e resolveu refatorar! üòè

```typescript
export interface Carro {
  acelerar();
  frear();
}
 
export interface MaquinaDoTempo {
  viajarNoTempo();
}
```

## Agora est√° tudo certo! üòç

```typescript
export class DeLorean implements Carro, MaquinaDoTempo {
  acelerar() {
    console.log('O DeLorean est√° sendo acelerado');
  }
 
  frear() {
    console.log('Voc√™ acabou de frear o DeLorean');
  }
 
  viajarNoTempo() {
    console.log('Vamos de volta para o futuro com o DeLorean');
  }
}
```
Ao realizar estas altera√ß√µes voltamos a respeitar o ISP, j√° que isolamos as interfaces da aplica√ß√£o atrav√©s das diferen√ßas de responsabilidade e comportamentos, e, portanto, passamos a ter interfaces espec√≠ficas ao inv√©s de interfaces gen√©ricas.

## Agora Wellington pode curtir a praia dele tranquil√£o! üòé

<img src="https://gifdb.com/images/high/vacation-mr-bean-s-holiday-7gf50xw9odioby08.gif" />

# Conclus√£o

Princ√≠pio da Segrega√ß√£o de Interface est√° relacionado a coes√£o de interfaces, definindo que classes ou componentes clientes n√£o devem ser for√ßados a depender de m√©todos que eles n√£o precisam. 

# Crie pequenas interfaces granulares que s√£o espec√≠ficas do cliente.

# Vamos ver mais um exemplo!

#

```php
interface Aves
{
    public function setLocalizacao($longitude, $latitude);
    public function setAltitude($altitude);
}
```

```php
class Papagaio implements Aves
{
    public function setLocalizacao($longitude, $latitude){}
    public function setAltitude($altitude){}
}

class Pinguim implements Aves
{
    public function setLocalizacao($longitude, $latitude){}
    
    // A Interface Aves est√° for√ßando a Classe Pinguim a implementar esse m√©todo.
    // Isso viola o pr√≠ncipio ISP
    public function setAltitude($altitude){
    //N√£o faz nada...  Pinguins s√£o aves que n√£o voam!
    }
}
```

# Acertando as coisas

```php
<?php

interface Aves
{
    public function setLocalizacao($longitude, $latitude);
}

interface AvesQueVoam extends Aves
{
    public function setAltitude($altitude);
}


<?php

interface Aves
{
    public function setLocalizacao($longitude, $latitude);
    public function renderizar();
}

interface AvesQueVoam extends Aves
{
    public function setAltitude($altitude);
}

class Papagaio implements AvesQueVoam{}
class Pinguim implements Aves{}

```


# D -> *Dependency Inversion Principle* ou Princ√≠pio da Invers√£o de Depend√™ncia

Sempre dependa de abstra√ß√µes, nunca de implementa√ß√µes concretas.

## Importante!

- M√≥dulos de alto n√≠vel n√£o devem depender de m√≥dulos de baixo n√≠vel. Ambos devem depender da abstra√ß√£o.

- Abstra√ß√µes n√£o devem depender de detalhes. Detalhes devem depender de abstra√ß√µes.

# üí©
```php

<?php

use MySQLConnection;

class PasswordReminder
{
    private $dbConnection;
    
    public function __construct()
    {       
        $this->dbConnection = new MySQLConnection();           
    }
    
    // Faz alguma coisa
}
```

# Qual o problema agora?

- a classe PasswordReminder, precisa conectar na base de dados, por tanto, ela cria um instancia da classe MySQLConnection;
- Isso causa um alto n√≠vel de acoplamento! Isso acontece porque a classe PasswordReminder tem a responsabilidade de criar uma inst√¢ncia da classe MySQLConnection.

# Resolvendo o problema!
```php

<?php

use MySQLConnection;

class PasswordReminder
{
    private $dbConnection;
    
    public function __construct(MySQLConnection $dbConnection)
    {       
        $this->dbConnection = $dbConnection;           
    }
    
    // Faz alguma coisa
}
```
# Agora temos a Inje√ß√£o de Depend√™ncia!

# Mas nem tudo s√£o flores ... üò¢

Apesar de termos usado a inje√ß√£o de depend√™ncia para melhorar o n√≠vel de acoplamento do nosso c√≥digo, ele ainda viola o princ√≠pio da invers√£o de depend√™ncia! ‚Äî lembre-se, um n√£o √© igual ao outro.

- Al√©m disso violamos o OCP, se precisarmos alterar o banco de dados, precisaremos mexer na classe PasswordReminder.

# Por que violamos o Dependency Inversion Principle? ü§¨

Porque estamos dependendo de uma implementa√ß√£o e n√£o de uma abstra√ß√£o!

# Um m√≥dulo de alto n√≠vel n√£o deve depender de m√≥dulos de baixo n√≠vel, ambos devem depender da abstra√ß√£o. ü§î
- Vamos no exemplo identificar qual √© alto n√≠vel e baixo n√≠vel!

## PasswordReminder depende da classe MySQLConnection

- Sendo assim, PasswordReminder √© o m√≥dulo de alto n√≠vel e MySQLConnection √© o m√≥dulo de baixo n√≠vel.

Velho ditado em POO: üëè

- Programe para uma interface e n√£o para uma implementa√ß√£o.

# Vamos come√ßar a refatora√ß√£o!

<img src="https://media.tenor.com/myWhE0y5rTsAAAAC/brent-rambo-thumbs-up.gif" />

# Criando a interface

```php
interface DBConnectionInterface
{
    public function connect();
}
```

## Implementando a interface

```php
class MySQLConnection implements DBConnectionInterface
{
    public function connect()
    {
        // ...
    }
}

class MongoDBConnection implements DBConnectionInterface
{
    public function connect()
    {
        // ...
    }
}

class OracleConnection implements DBConnectionInterface
{
    public function connect()
    {
        // ...
    }
}
```

# Password Reminder

```php
class PasswordReminder
{
    private $dbConnection;
    public function __construct(DBConnectionInterface $dbConnection) {
        $this->dbConnection = $dbConnection;
    }
    // Faz alguma coisa
}
```

# üòç

- Agora a classe PasswordReminder n√£o tem a m√≠nima ideia de qual banco de dados a aplica√ß√£o ir√° utilizar;
- As classes est√£o desacopladas e dependendo de uma abstra√ß√£o (DBConnectionInterface);
- Estamos favorecendo a reusabilidade do c√≥digo;
- SRP ü§å
- OCP ü§å

# Bora mais um exemplo ??? ü•∫

<img src="https://media.tenor.com/HPht2t341E8AAAAC/puppy-dog-eyes-sad.gif" />

## Aten√ß√£o ao acoplamento!

```typescript
import { SendGridService } from '../../services'; // <- C√≥digo Fonte da depend√™ncia

class InserirUsuarioController extends BaseController {
                                                        
  private emailService: SendGridService = new SendGridService(); // <- classe concreta

  constructor () {
  }

  protected enviarEmail (): void {
    // enviar email
    const email = new Email(...)
    this.emailService.sendMail(mail);
  }
}
```

## Aten√ß√£o ao acoplamento!

```typescript
class InserirUsuarioController extends BaseController {

  constructor (private emailService: SendGridService) { // <- classe concreta
  }

  protected enviarEmail (): void {
    
    // envia mail
    const email = new Email(...)
    this.emailService.sendMail(email);
  }
}
```

## Ajustando as coisas! üòç

```typescript
interface IEmailService {
  sendMail() : void;
}

class InserirUsuarioController extends BaseController {

  constructor (private emailService: IEmailService) { // <- abstra√ß√£o
  }

  protected enviarEmail (): void {
    // envia mail
    const email = new Email(...)
    this.emailService.sendMail(email);
  }
}
```

# S√≥ mais 1 exemplo! Eu JURO! üòá

## Vamos pensar nas depend√™ncias

<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*ctCgGCiNCWDM6DIyejMj3Q.png" />

As depend√™ncias seguem uma sequ√™ncia, onde o fluxo come√ßa com a fun√ß√£o de alto n√≠vel (gerarNotaFiscal), que depende de uma fun√ß√£o de baixo n√≠vel (calcular) que, por sua vez, depende de um detalhe (obterProdutos).


## Olhando o c√≥digo:
```php
function gerarNotaFiscal(int $pedidoId)
{
    $pre√ßoPedido = calcular($pedidoId);
    // rotina para gerar a nota fiscal
}
function calcular(int $pedidoId) : float
{
    $produtos = obterProdutos($pedidoId);
    // rotina que calcula a soma de todos os produtos
    return 678.50;
}
function obterProdutos(int $pedidoId) : array
{
    // rotina que busca a lista de produtos
    // no banco de dados com base no id do pedido
    return [];
}
```

## Refatorando de procedural para OO
```php
class NotaFiscal
{
    public function gerarNota(int $pedidoId)
    {
        $calculo = new Calculo;
        $pre√ßoPedido = $calculo->calcularPre√ßoPedido();
        // rotina para gerar a nota fiscal
    }
}
class Calculo
{
    public function calcularPre√ßoPedido(int $pedidoId) : void
    {
        $produtos = new Produtos;
        $lista = $produtos->obterProdutos($pedidoId);
        // rotina que calcula a soma de todos os produtos
        return 678.50;
    }
}
class Produtos
{
    public function obterProdutos(int $pedidoId) : array
    {
        // rotina que busca a lista de produtos
        // no banco de dados com base no id do pedido
        return [];
    }
}
```

# As depend√™ncias continuam seguindo a mesma sequ√™ncia ü•≤

## Qualquer mudan√ßa em qualquer uma dessas classes ir√° quebrar todas as que estiverem ligadas a partir das depend√™ncias provenientes do acoplamento.

<img src="https://media.tenor.com/VTBy6ITcbE4AAAAC/doctor-who-rain.gif" />

## Invertendo as depend√™ncias

<img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*N-cNf7xTIqh3cpnQthEJnQ.png" />

No diagrama acima a dire√ß√£o das cetas indica a depend√™ncia das classes. Note que a ceta vermelha est√° invertida, quebrando a cascata. Agora, todas as classes dependem de abstra√ß√µes (ICalculoPedidos e IProdutos).

# Hora do c√≥digo! ü•≥

```php
class NotaFiscal
{
    public function gerarNota(ICalculo $calculo)
    {
        $pre√ßoPedido = $calculo->total();
        // rotina para gerar a nota fiscal
    }
}
```

# üò≤

```php
interface ICalculo
{
    public function calcularPre√ßoPedido(IProdutos $produtos) : void;
    public function total() : float;
}
class Calculo implements ICalculo 
{
    private $produtos;
    public function calcularPre√ßoPedido(IProdutos $produtos) : void
    {
        $this->produtos = $produtos;
    }
    public function total() : float
    {
        $lista = $this->produtos->obterProdutos();
        // rotina que soma os pre√ßos dos produtos ...
        return 678.50;
    }
}
```

# üò≤

```php
interface IProdutos
{
    public function setarPedidoId(int $pedidoId) : void;
    public function obterProdutos() : array;
}
class Produtos implements IProdutos
{
    private $pedidoId;
    public function setarPedidoId(int $pedidoId) : void
    {
        $this->pedidoId = $pedidoId;
    }
    public function obterProdutos() : array
    {
        return $this->consultarNoBanco($this->pedidoId);
    }
    private function consultarNoBanco(int $pedidoId) : array
    {
        // implementa√ß√£o qualquer ...
        return [];
    }
}
```

## √â uma boa pr√°tica programar para interfaces, pois isso diminui o acoplamento entre as classes, e n√£o tornamos dependentes delas!

-  Quando voc√™ estabelece qual a interface utilizada, voc√™ j√° definiu um contrato entre a classe e o tipo;
- A partir da√≠, n√£o importa qual √© exatamente a classe recebida como par√¢metro do construtor, desde que ela implemente a interface.
